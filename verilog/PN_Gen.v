// Module: PN_Gen
// ==============
// This module generates a pseudo-random sequence.
// The sequence is generated by a linear feedback shift register (LFSR).
// Supports arbitrary N-bit LFSR using maximal-length polynomials.
//
// Supported LFSR polynomials (standard maximal-length feedback):
// N=2:  x^2 + x + 1                    (taps: [2,1])
// N=3:  x^3 + x^2 + 1                  (taps: [3,2])
// N=4:  x^4 + x^3 + 1                  (taps: [4,3])
// N=5:  x^5 + x^3 + 1                  (taps: [5,3])
// N=6:  x^6 + x^5 + 1                  (taps: [6,5])
// N=7:  x^7 + x^6 + 1                  (taps: [7,6])
// N=8:  x^8 + x^6 + x^5 + x^4 + 1      (taps: [8,6,5,4])
// N=9:  x^9 + x^5 + 1                  (taps: [9,5])
// N=10: x^10 + x^7 + 1                 (taps: [10,7])
// N=11: x^11 + x^9 + 1                 (taps: [11,9])
// N=12: x^12 + x^11 + x^10 + x^4 + 1   (taps: [12,11,10,4])
// N=13: x^13 + x^12 + x^11 + x^8 + 1   (taps: [13,12,11,8])
// N=14: x^14 + x^13 + x^12 + x^2 + 1   (taps: [14,13,12,2])
// N=15: x^15 + x^14 + 1                (taps: [15,14])
// N=16: x^16 + x^15 + x^13 + x^4 + 1   (taps: [16,15,13,4])
//

// Author: LiPtP
// Date: 2024/01/05
// Modified: 2025/12/17 - Extended to support arbitrary N

`timescale 1ns / 1ps

module PN_Gen #(
    parameter N = 5
) (
    input      clk,
    input      clk_enable,
    output reg pn
);
    reg  [N-1:0] PN_buf = 1;
    wire         rst;
    wire         feedback;

    // Function to compute LFSR feedback based on N
    function automatic feedback_calc;
        input [N-1:0] state;
        reg fb;
        begin
            case (N)
                2: fb = state[1] ^ state[0];  // x^2 + x + 1
                3: fb = state[2] ^ state[1];  // x^3 + x^2 + 1
                4: fb = state[3] ^ state[2];  // x^4 + x^3 + 1
                5: fb = state[4] ^ state[2];  // x^5 + x^3 + 1
                6: fb = state[5] ^ state[4];  // x^6 + x^5 + 1
                7: fb = state[6] ^ state[5];  // x^7 + x^6 + 1
                8: fb = state[7] ^ state[5] ^ state[4] ^ state[3];  // x^8 + x^6 + x^5 + x^4 + 1
                9: fb = state[8] ^ state[4];  // x^9 + x^5 + 1
                10: fb = state[9] ^ state[6];  // x^10 + x^7 + 1
                11: fb = state[10] ^ state[8];  // x^11 + x^9 + 1
                12:
                fb = state[11] ^ state[10] ^ state[9] ^ state[3];  // x^12 + x^11 + x^10 + x^4 + 1
                13:
                fb = state[12] ^ state[11] ^ state[10] ^ state[7];  // x^13 + x^12 + x^11 + x^8 + 1
                14:
                fb = state[13] ^ state[12] ^ state[11] ^ state[1];  // x^14 + x^13 + x^12 + x^2 + 1
                15: fb = state[14] ^ state[13];  // x^15 + x^14 + 1
                16:
                fb = state[15] ^ state[14] ^ state[12] ^ state[3];  // x^16 + x^15 + x^13 + x^4 + 1
                17: fb = state[16] ^ state[13];  // x^17 + x^14 + 1
                18: fb = state[17] ^ state[10];  // x^18 + x^11 + 1
                19:
                fb = state[18] ^ state[17] ^ state[16] ^ state[13];          // x^19 + x^18 + x^17 + x^14 + 1
                20: fb = state[19] ^ state[16];  // x^20 + x^17 + 1
                21: fb = state[20] ^ state[18];  // x^21 + x^19 + 1
                22: fb = state[21] ^ state[20];  // x^22 + x^21 + 1
                23: fb = state[22] ^ state[17];  // x^23 + x^18 + 1
                24:
                fb = state[23] ^ state[22] ^ state[21] ^ state[16];          // x^24 + x^23 + x^22 + x^17 + 1
                25: fb = state[24] ^ state[21];  // x^25 + x^22 + 1
                26:
                fb = state[25] ^ state[24] ^ state[23] ^ state[19];          // x^26 + x^25 + x^24 + x^20 + 1
                27:
                fb = state[26] ^ state[24] ^ state[23] ^ state[21];          // x^27 + x^25 + x^24 + x^22 + 1
                28: fb = state[27] ^ state[24];  // x^28 + x^25 + 1
                29: fb = state[28] ^ state[26];  // x^29 + x^27 + 1
                30:
                fb = state[29] ^ state[28] ^ state[27] ^ state[21];          // x^30 + x^29 + x^28 + x^22 + 1
                31: fb = state[30] ^ state[27];  // x^31 + x^28 + 1
                32:
                fb = state[31] ^ state[30] ^ state[29] ^ state[9];  // x^32 + x^31 + x^30 + x^10 + 1
                default: fb = state[N-1] ^ state[N-2];  // fallback: x^N + x^(N-1) + 1
            endcase
            feedback_calc = fb;
        end
    endfunction

    assign feedback = feedback_calc(PN_buf);

    always @(posedge clk) begin
        if (rst) begin
            PN_buf <= {{(N - 1) {1'b0}}, 1'b1};  // initial state: 0...01
            pn <= 0;
        end else if (clk_enable) begin
            PN_buf <= {PN_buf[N-2:0], feedback};
            pn <= PN_buf[N-1];
        end
    end

    assign rst = !(|PN_buf);  // reset when PN_buf is all 0
endmodule
